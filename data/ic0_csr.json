[
  [
    {
      "Name" : "CSR Incoplete Cholesky 0",
      "Input Type" : "IEgenLIB Relation",
      "Index" : "1",
      "Relation" : "{ [i] -> [ip] : row(i) = row(ip) && i < ip && 0 <= i && i < n-1 && 0 <= ip && ip < n-1 }",

      "Efficient Inspector complexity:" : "O( n*n )",

      "What helps to detect unsat 1:" : "Mono",

      "Expected" : "Not Satisfiable",
      "UFS" :
      [
        { 
           "Name" : "col",
           "Domain" : "{[i]:0<=i && i<nnz}",
           "Range" : "{[j]: 0<=j && j<m}",
           "Bijective" : "false",
           "Monotonicity" : "Monotonic_NONE"
        },
        { 
           "Name" : "row",
           "Domain" : "{[j]:0<=j &&j<m}",
           "Range" : "{[i]:0<=i &&i<nnz}",
           "Bijective" : "false",
           "Monotonicity" : "Monotonic_Increasing"
        }
      ],
      "User Defined" :
      [
      ],
      "Do Not Project Out" :
      [
        "i", "ip"
      ],
      "Remove Constraints" : "0",
      "Comment: Code" : [
                  "Following is the CSR Incoplete Cholesky 0 code.", 
                  "Dependence analysis of this code would identify",
                  "21 pairs of read/write or write/write data accesses",
                  "in or between S1, S2, and S3 that may produce dependences.",
                  "Each of these pairs produces two conjunctions considering",
                  "the ordering of accesses (Flow and Anti dependence).",
                  "Overall, there are 30 distinct conjunctions for",
                  "the complete dependence relation.",
                  " ",
                  "for (i = 0; i < n - 1; i++){",
                  "  val[row[i]] = sqrt(val[row[i]]);      //S1",
                  "  for (m = row[i] + 1; m < row[i+1]; m++){",
                  "    val[m] = val[m] / val[row[i]];      //S2",
                  "  }",
                  "  for (m = row[i] + 1; m < row[i+1]; m++) {",
                  "    for (k = row[col[m]] ; k < row[col[m]+1]; k++){",
                  "      for ( l = m; l && l < row[i+1] ; l++){",
                  "        if (col[l] == col[k] && col[l+1] <= col[k]){",
                  "          val[k] -= val[m]* val[l];      //S3",
                  "        }", 
                  "      }",
                  "    }",
                  "  }",
                  "}"
                  ],
      "Comment: Source of data access in the code for this relation" : [
                    " ",
                    "a write in S1 (val[row[i]]);  a read in S1 (val[row[i]]);"
                  ]
    },
    {
      "Name" : "CSR Incoplete Cholesky 0",
      "Index" : "2",
      "Input Type" : "IEgenLIB Relation",
      "Relation" : "{ [i] -> [ip] : row(i) = row(ip) && ip < i && 0 <= i && i < n-1 && 0 <= ip && ip < n-1 }",

      "Efficient Inspector complexity:" : "O( n*n )",

      "What helps to detect unsat 1:" : "Mono",

      "Expected" : "Not Satisfiable",
      "Comment: Source of data access in the code for this relation" : [
                    " ",
                    "a write in S1 (val[row[i]]);  a read in S1 (val[row[i]]);"
                  ]
    },
    {
      "Name" : "CSR Incoplete Cholesky 0",
      "Input Type" : "IEgenLIB Relation",
      "Index" : "3",
      "Relation" : "{ [i] -> [ip,mp] : row(i) = row(ip) && i < ip && 0 <= i && i < n-1 && 0 <= ip && ip < n-1 && row(ip)+1 <= mp && mp < row(ip+1) }",

      "Efficient Inspector complexity:" : "O( n*n )",

      "What helps to detect unsat 1:" : "Mono",

      "Expected" : "Not Satisfiable",
      "Comment: Source of data access in the code for this relation" : [
                    " ",
                    "a write in S1 (val[row[i]]);  a read in S2 (val[row[i]]);"
                  ]
    },
    {
      "Name" : "CSR Incoplete Cholesky 0",
      "Input Type" : "IEgenLIB Relation",
      "Index" : "4",
      "Relation" : "{ [i] -> [ip,mp] : row(i) = row(ip) && ip < i && 0 <= i && i < n-1 && 0 <= ip && ip < n-1 && row(ip)+1 <= mp && mp < row(ip+1) }",

      "Efficient Inspector complexity:" : "O( n*n )",

      "What helps to detect unsat 1:" : "Mono",

      "Expected" : "Not Satisfiable",
      "Comment: Source of data access in the code for this relation" : [
                    " ",
                    "a write in S1 (val[row[i]]);  a read in S2 (val[row[i]]);"
                  ]
    },
    {
      "Name" : "CSR Incoplete Cholesky 0",
      "Input Type" : "IEgenLIB Relation",
      "Index" : "5",
      "Relation" : "{ [i] -> [ip,mp] : row(i) = mp && i < ip && 0 <= i && i < n-1 && 0 <= ip && ip < n-1 && row(ip)+1 <= mp && mp < row(ip+1) }",

      "Efficient Inspector complexity:" : "O( n*n )",

      "What helps to detect unsat 1:" : "Mono",

      "Expected" : "Not Satisfiable",
      "Comment: Source of data access in the code for this relation" : [
                    " ",
                    "a write in S1 (val[row[i]]);  a read in S2 (val[m]);"
                  ]
    },
    {
      "Name" : "CSR Incoplete Cholesky 0",
      "Input Type" : "IEgenLIB Relation",
      "Index" : "6",
      "Relation" : "{ [i] -> [ip,mp] : row(i) = mp && ip < i && 0 <= i && i < n-1 && 0 <= ip && ip < n-1 && row(ip)+1 <= mp && mp < row(ip+1) }",

      "Efficient Inspector complexity:" : "O( n*n )",

      "Expected" : "Not Satisfiable",
      "Comment: Source of data access in the code for this relation" : [
                    " ",
                    "a write in S1 (val[row[i]]);  a read in S2 (val[m]);"
                  ]
    },
    {
      "Name" : "CSR Incoplete Cholesky 0",
      "Input Type" : "IEgenLIB Relation",
      "Index" : "7",
      "Relation" : "{ [i] -> [ip,mp,kp,lp] : row(i) = mp && i < ip && 0 <= i && i < n-1 && 0 <= ip && ip < n-1 && row(ip)+1 <= mp && mp < row(ip+1) && row(col(mp)) <= kp && kp < row(col(mp)+1) && mp <= lp && lp < row(ip+1) && col(lp+1) <= col(kp) && col(lp) = col(kp)}",

      "Efficient Inspector complexity:" : " n*n*(nnz/n)*(nnz/n) = O( nnz^2 )",

      "What helps to detect unsat 1:" : "Mono",

      "Expected" : "Not Satisfiable",
      "Comment: Source of data access in the code for this relation" : [
                    " ",
                    "a write in S1 (val[row[i]]);  a read in S3 (val[m]);"
                  ]
    },
    {
      "Name" : "CSR Incoplete Cholesky 0",
      "Input Type" : "IEgenLIB Relation",
      "Index" : "8",
      "Relation" : "{ [i] -> [ip,mp,kp,lp] : row(i) = mp && ip < i && 0 <= i && i < n-1 && 0 <= ip && ip < n-1 && row(ip)+1 <= mp && mp < row(ip+1) && row(col(mp)) <= kp && kp < row(col(mp)+1) && mp <= lp && lp < row(ip+1) && col(lp+1) <= col(kp) && col(lp) = col(kp)}",

      "Efficient Inspector complexity:" : " n*n*(nnz/n)*(nnz/n) = O( nnz^2 )",

      "What helps to detect unsat 1:" : "Mono",

      "Expected" : "Not Satisfiable",
      "Comment: Source of data access in the code for this relation" : [
                    " ",
                    "a write in S1 (val[row[i]]);  a read in S3 (val[m]);"
                  ]
    },
    {
      "Name" : "CSR Incoplete Cholesky 0",
      "Input Type" : "IEgenLIB Relation",
      "Index" : "9",
      "Relation" : "{ [i] -> [ip,mp,kp,lp] : row(i) = lp && i < ip && 0 <= i && i < n-1 && 0 <= ip && ip < n-1 && row(ip)+1 <= mp && mp < row(ip+1) && row(col(mp)) <= kp && kp < row(col(mp)+1) && mp <= lp && lp < row(ip+1) && col(lp+1) <= col(kp) && col(lp) = col(kp)}",

      "Efficient Inspector complexity:" : " n*n*(nnz/n)*(nnz/n) = O( nnz^2 )",

      "What helps to detect unsat 1:" : "Mono",

      "Expected" : "Not Satisfiable",
      "Comment: Source of data access in the code for this relation" : [
                    " ",
                    "a write in S1 (val[row[i]]);  a read in S3 (val[l]);"
                  ]
    },
    {
      "Name" : "CSR Incoplete Cholesky 0",
      "Input Type" : "IEgenLIB Relation",
      "Index" : "10",
      "Relation" : "{ [i] -> [ip,mp,kp,lp] : row(i) = lp && ip < i && 0 <= i && i < n-1 && 0 <= ip && ip < n-1 && row(ip)+1 <= mp && mp < row(ip+1) && row(col(mp)) <= kp && kp < row(col(mp)+1) && mp <= lp && lp < row(ip+1) && col(lp+1) <= col(kp) && col(lp) = col(kp)}",

      "Efficient Inspector complexity:" : " n*n*(nnz/n)*(nnz/n) = O( nnz^2 )",

      "What helps to detect unsat 1:" : "Mono",

      "Expected" : "Not Satisfiable",
      "Comment: Source of data access in the code for this relation" : [
                    " ",
                    "a write in S1 (val[row[i]]);  a read in S3 (val[l]);"
                  ]
    },
    {
      "Name" : "CSR Incoplete Cholesky 0",
      "Input Type" : "IEgenLIB Relation",
      "Index" : "11",
      "Relation" : "{ [i,m,k,l] -> [ip] : k = row(ip) && i < ip && 0 <= i && i < n-1 && 0 <= ip && ip < n-1 && row(i)+1 <= m && m < row(i+1) && row(col(m)) <= k && k < row(col(m)+1) && m <= l && l < row(i+1) && col(l+1) <= col(k) && col(l) = col(k)}",

      "Efficient Inspector complexity:" : " n*n*(nnz/n)*(nnz/n) = O( nnz^2 )",

      "Efficient Inspector complexity after domain info (mono adds an useful equlaity: ip = col(m) ):" : " (nnz^2)*(1/n) = O( (nnz^2)/n )",

      "Expected" : "Maybe Satisfiable",
      "Comment: Source of data access in the code for this relation" : [
                    " ",
                    "a read in S1 (val[row[i]]);  a write in S3 (val[k]);"
                  ]
    },
    {
      "Name" : "CSR Incoplete Cholesky 0",
      "Input Type" : "IEgenLIB Relation",
      "Index" : "12",
      "Relation" : "{ [i,m,k,l] -> [ip] : k = row(ip) && ip < i && 0 <= i && i < n-1 && 0 <= ip && ip < n-1 && row(i)+1 <= m && m < row(i+1) && row(col(m)) <= k && k < row(col(m)+1) && m <= l && l < row(i+1) && col(l+1) <= col(k) && col(l) = col(k)}",

      "Efficient Inspector complexity:" : "O( n*n*(nnz/n)*(nnz/n) = O( nnz^2 ))",

      "Efficient Inspector complexity after domain info (mono adds an useful equlaity: ip = col(m) ):" : " (nnz^2)*(1/n) = O( (nnz^2)/n )",

      "Expected" : "Maybe Satisfiable",
      "Comment: Source of data access in the code for this relation" : [
                    " ",
                    "a read in S1 (val[row[i]]);  a write in S3 (val[k]);"
                  ]
    },
    {
      "Name" : "CSR Incoplete Cholesky 0",
      "Input Type" : "IEgenLIB Relation",
      "Index" : "13",
      "Relation" : "{ [i,m] -> [ip,mp] : m = mp && i < ip && 0 <= i && i < n-1 && 0 <= ip && ip < n-1  && row(i)+1 <= m && m < row(i+1) && row(ip)+1 <= mp && mp < row(ip+1) }",

      "Efficient Inspector complexity:" : "O( n*n )",

      "What helps to detect unsat 1:" : "Mono",

      "Expected" : "Not Satisfiable",
      "Comment: Source of data access in the code for this relation" : [
                    " ",
                    "a write in S2 (val[m]);  a read in S2 (val[m]);"
                  ]
    },
    {
      "Name" : "CSR Incoplete Cholesky 0",
      "Input Type" : "IEgenLIB Relation",
      "Index" : "14",
      "Relation" : "{ [i,m] -> [ip,mp] : m = mp && ip < i && 0 <= i && i < n-1 && 0 <= ip && ip < n-1  && row(i)+1 <= m && m < row(i+1) && row(ip)+1 <= mp && mp < row(ip+1) }",

      "Efficient Inspector complexity:" : "O( n*n )",

      "What helps to detect unsat 1:" : "Mono",

      "Expected" : "Not Satisfiable",
      "Comment: Source of data access in the code for this relation" : [
                    " ",
                    "a write in S2 (val[m]);  a read in S2 (val[m]);"
                  ]
    },

    {
      "Name" : "CSR Incoplete Cholesky 0",
      "Input Type" : "IEgenLIB Relation",
      "Index" : "15",
      "Relation" : "{ [i,m] -> [ip,mp] : m = row(ip) && i < ip && 0 <= i && i < n-1 && 0 <= ip && ip < n-1  && row(i)+1 <= m && m < row(i+1) && row(ip)+1 <= mp && mp < row(ip+1) }",

      "Efficient Inspector complexity:" : "O( n*n )",

      "What helps to detect unsat 1:" : "Mono",

      "Expected" : "Not Satisfiable",
      "Comment: Source of data access in the code for this relation" : [
                    " ",
                    "a write in S2 (val[m]);  a read in S2 (val[row[i]]);"
                  ]
    },
    {
      "Name" : "CSR Incoplete Cholesky 0",
      "Input Type" : "IEgenLIB Relation",
      "Index" : "16",
      "Relation" : "{ [i,m] -> [ip,mp] : m = row(ip) && ip < i && 0 <= i && i < n-1 && 0 <= ip && ip < n-1  && row(i)+1 <= m && m < row(i+1) && row(ip)+1 <= mp && mp < row(ip+1) }",

      "Efficient Inspector complexity:" : "O( n*n )",

      "What helps to detect unsat 1:" : "Mono",

      "Expected" : "Not Satisfiable",
      "Comment: Source of data access in the code for this relation" : [
                    " ",
                    "a write in S2 (val[m]);  a read in S2 (val[row[i]]);"
                  ]
    },
    {
      "Name" : "CSR Incoplete Cholesky 0",
      "Input Type" : "IEgenLIB Relation",
      "Index" : "17",
      "Relation" : "{ [i,m,k,l] -> [ip,mp] : k = row(ip) && i < ip && 0 <= i && i < n-1 && 0 <= ip && ip < n-1  && row(i)+1 <= m && m < row(i+1) && row(ip)+1 <= mp && mp < row(ip+1) && row(col(m)) <= k && k < row(col(m)+1) && m <= l && l < row(i+1) && col(l+1) <= col(k) && col(l) = col(k)}",

      "Efficient Inspector complexity:" : " n*n*(nnz/n)*(nnz/n) = O( nnz^2 )",

      "Efficient Inspector complexity after domain info (mono adds an useful equlaity: ip = col(m) ):" : " (nnz^2)*(1/n) = O( (nnz^2)/n )",

      "Expected" : "Maybe Satisfiable",
      "Comment: Source of data access in the code for this relation" : [
                    " ",
                    "a read in S2 (val[row[i]]);  a write in S3 (val[k]);"
                  ]
    },
    {
      "Name" : "CSR Incoplete Cholesky 0",
      "Input Type" : "IEgenLIB Relation",
      "Index" : "18",
      "Relation" : "{ [i,m,k,l] -> [ip,mp] : k = row(ip) && ip < i && 0 <= i && i < n-1 && 0 <= ip && ip < n-1  && row(i)+1 <= m && m < row(i+1) && row(ip)+1 <= mp && mp < row(ip+1) && row(col(m)) <= k && k < row(col(m)+1) && m <= l && l < row(i+1) && col(l+1) <= col(k) && col(l) = col(k)}",

      "Efficient Inspector complexity:" : " n*n*(nnz/n)*(nnz/n) = O( nnz^2 )",

      "Efficient Inspector complexity after domain info (mono adds an useful equlaity: ip = col(m) ):" : " (nnz^2)*(1/n) = O( (nnz^2)/n )",

      "Expected" : "Maybe Satisfiable",
      "Comment: Source of data access in the code for this relation" : [
                    " ",
                    "a read in S2 (val[row[i]]);  a write in S3 (val[k]);"
                  ]
    },
    {
      "Name" : "CSR Incoplete Cholesky 0",
      "Input Type" : "IEgenLIB Relation",
      "Index" : "19",
      "Relation" : "{ [i,m,k,l] -> [ip,mp] : k = mp && i < ip && 0 <= i && i < n-1 && 0 <= ip && ip < n-1  && row(i)+1 <= m && m < row(i+1) && row(ip)+1 <= mp && mp < row(ip+1) && row(col(m)) <= k && k < row(col(m)+1) && m <= l && l < row(i+1) && col(l+1) <= col(k) && col(l) = col(k)}",

      "Efficient Inspector complexity:" : "n*n*(nnz/n)*(nnz/n)*(nnz/n) = O( nnz^3/n )",
      "Tricky!":"Please note that we remove useful equlity with projection as a bad side effect, however, since we are not considering an oracle process, we always assume we apply projection first then use equalities.",

      "Efficient Inspector complexity after domain info (mono adds an useful equlaity: ip = col(m) ):" : " (nnz^3)*(1/n) = O( (nnz^3)/n^2 )",

      "Expected" : "Maybe Satisfiable",
      "Comment: Source of data access in the code for this relation" : [
                    " ",
                    "a read in S2 (val[m]);  a write in S3 (val[k]);"
                  ]
    },
    {
      "Name" : "CSR Incoplete Cholesky 0",
      "Input Type" : "IEgenLIB Relation",
      "Index" : "20",
      "Relation" : "{ [i,m,k,l] -> [ip,mp] : k = mp && ip < i && 0 <= i && i < n-1 && 0 <= ip && ip < n-1  && row(i)+1 <= m && m < row(i+1) && row(ip)+1 <= mp && mp < row(ip+1) && row(col(m)) <= k && k < row(col(m)+1) && m <= l && l < row(i+1) && col(l+1) <= col(k) && col(l) = col(k)}",

      "Efficient Inspector complexity:" : "n*n*(nnz/n)*(nnz/n)*(nnz/n) = O( nnz^3/n )",
      "Tricky!":"Please note that we remove useful equlity with projection as a bad side effect, however, since we are not considering an oracle process, we always assume we apply projection first then use equalities.",

      "Efficient Inspector complexity after domain info (mono adds an useful equlaity: ip = col(m) ):" : " (nnz^3)*(1/n) = O( (nnz^3)/n^2 )",

      "Expected" : "Maybe Satisfiable",
      "Comment: Source of data access in the code for this relation" : [
                    " ",
                    "a read in S2 (val[m]);  a write in S3 (val[k]);"
                  ]
    },
    {
      "Name" : "CSR Incoplete Cholesky 0",
      "Input Type" : "IEgenLIB Relation",
      "Index" : "21",
      "Relation" : "{ [i,m] -> [ip,mp,kp,lp] : m = mp && i < ip && 0 <= i && i < n-1 && 0 <= ip && ip < n-1  && row(i)+1 <= m && m < row(i+1) && row(ip)+1 <= mp && mp < row(ip+1) && row(col(mp)) <= kp && kp < row(col(mp)+1) && mp <= lp && lp < row(ip+1) && col(lp+1) <= col(kp) && col(lp) = col(kp)}",

      "Efficient Inspector complexity:" : "n*n*(nnz/n)*(nnz/n)*(nnz/n) = O( nnz^3/n )",

      "What helps to detect unsat 1:" : "Mono",

      "Expected" : "Not Satisfiable",
      "Comment: Source of data access in the code for this relation" : [
                    " ",
                    "a write in S2 (val[m]);  a read in S3 (val[m]);"
                  ]
    },
    {
      "Name" : "CSR Incoplete Cholesky 0",
      "Input Type" : "IEgenLIB Relation",
      "Index" : "22",
      "Relation" : "{ [i,m] -> [ip,mp,kp,lp] : m = mp && ip < i && 0 <= i && i < n-1 && 0 <= ip && ip < n-1  && row(i)+1 <= m && m < row(i+1) && row(ip)+1 <= mp && mp < row(ip+1) && row(col(mp)) <= kp && kp < row(col(mp)+1) && mp <= lp && lp < row(ip+1) && col(lp+1) <= col(kp) && col(lp) = col(kp)}",

      "Efficient Inspector complexity:" : " n*n*(nnz/n)*(nnz/n)*(nnz/n) = O( nnz^3/n ) )",

      "What helps to detect unsat 1:" : "Mono",

      "Expected" : "Not Satisfiable",
      "Comment: Source of data access in the code for this relation" : [
                    " ",
                    "a write in S2 (val[m]);  a read in S3 (val[m]);"
                  ]
    }, 
    {
      "Name" : "CSR Incoplete Cholesky 0",
      "Input Type" : "IEgenLIB Relation",
      "Index" : "23",
      "Relation" : "{ [i,m] -> [ip,mp,kp,lp] : m = lp && i < ip && 0 <= i && i < n-1 && 0 <= ip && ip < n-1  && row(i)+1 <= m && m < row(i+1) && row(ip)+1 <= mp && mp < row(ip+1) && row(col(mp)) <= kp && kp < row(col(mp)+1) && mp <= lp && lp < row(ip+1) && col(lp+1) <= col(kp) && col(lp) = col(kp)}",

      "Efficient Inspector complexity:" : "n*n*(nnz/n)*(nnz/n)*(nnz/n) = O( nnz^3/n ) )",

      "What helps to detect unsat 1:" : "Mono",

      "Expected" : "Not Satisfiable",
      "Comment: Source of data access in the code for this relation" : [
                    " ",
                    "a write in S2 (val[m]);  a read in S3 (val[l]);"
                  ]
    },
    {
      "Name" : "CSR Incoplete Cholesky 0",
      "Input Type" : "IEgenLIB Relation",
      "Index" : "24",
      "Relation" : "{ [i,m] -> [ip,mp,kp,lp] : m = lp && ip < i && 0 <= i && i < n-1 && 0 <= ip && ip < n-1  && row(i)+1 <= m && m < row(i+1) && row(ip)+1 <= mp && mp < row(ip+1) && row(col(mp)) <= kp && kp < row(col(mp)+1) && mp <= lp && lp < row(ip+1) && col(lp+1) <= col(kp) && col(lp) = col(kp)}",

      "Efficient Inspector complexity:" : "n*n*(nnz/n)*(nnz/n)*(nnz/n) = O( nnz^3/n ) )",

      "What helps to detect unsat 1:" : "Mono",

      "Expected" : "Not Satisfiable",
      "Comment: Source of data access in the code for this relation" : [
                    " ",
                    "a write in S2 (val[m]);  a read in S3 (val[l]);"
                  ]
    },
    {
      "Name" : "CSR Incoplete Cholesky 0",
      "Input Type" : "IEgenLIB Relation",
      "Index" : "25",
      "Relation" : "{ [i,m,k,l] -> [ip,mp,kp,lp] : k = kp && i < ip  && 0 <= i && i < n-1 && 0 <= ip && ip < n-1  && row(i)+1 <= m && m < row(i+1) && row(ip)+1 <= mp && mp < row(ip+1) && row(col(m)) <= k && k < row(col(m)+1) && row(col(mp)) <= kp && kp < row(col(mp)+1) && m <= l && l < row(i+1) && mp <= lp && lp < row(ip+1) && col(lp+1) <= col(kp) && col(l+1) <= col(k) && col(l) = col(k) && col(lp) = col(kp)}",

      "Efficient Inspector complexity:" : "n*(nnz/n)*(nnz/n)*(nnz/n)*n*(nnz/n)*(nnz/n) = O( nnz^5/n^3 )",

      "Efficient Inspector complexity after domain info (mono adds an useful equlaity: ip = col(m) ):" : "     n*(nnz/n)*(nnz/n)*(nnz/n)*(nnz/n)*(nnz/n) = O( nnz^5/n^4 )",

      "Expected" : "Maybe Satisfiable",
      "Comment: Source of data access in the code for this relation" : [
                    " ",
                    "a write in S3 (val[k]);  a write in S3 (val[k]);"
                  ]
    },
    {
      "Name" : "CSR Incoplete Cholesky 0",
      "Input Type" : "IEgenLIB Relation",
      "Index" : "26",
      "Relation" : "{ [i,m,k,l] -> [ip,mp,kp,lp] : k = kp && ip < i  && 0 <= i && i < n-1 && 0 <= ip && ip < n-1  && row(i)+1 <= m && m < row(i+1) && row(ip)+1 <= mp && mp < row(ip+1) && row(col(m)) <= k && k < row(col(m)+1) && row(col(mp)) <= kp && kp < row(col(mp)+1) && m <= l && l < row(i+1) && mp <= lp && lp < row(ip+1) && col(lp+1) <= col(kp) && col(l+1) <= col(k) && col(l) = col(k) && col(lp) = col(kp)}",

      "Efficient Inspector complexity:" : "n*(nnz/n)*(nnz/n)*(nnz/n)*n*(nnz/n)*(nnz/n) = O( nnz^5/n^3 )",

      "Efficient Inspector complexity after domain info (mono adds an useful equlaity: ip = col(m) ):" : "     n*(nnz/n)*(nnz/n)*(nnz/n)*(nnz/n)*(nnz/n) = O( nnz^5/n^4 )",

      "Expected" : "Maybe Satisfiable",
      "Comment: Source of data access in the code for this relation" : [
                    " ",
                    "a write in S3 (val[k]);  a write in S3 (val[k]);"
                  ]
    },
    {
      "Name" : "CSR Incoplete Cholesky 0",
      "Input Type" : "IEgenLIB Relation",
      "Index" : "27",
      "Relation" : "{ [i,m,k,l] -> [ip,mp,kp,lp] : k = lp && i < ip  && 0 <= i && i < n-1 && 0 <= ip && ip < n-1  && row(i)+1 <= m && m < row(i+1) && row(ip)+1 <= mp && mp < row(ip+1) && row(col(m)) <= k && k < row(col(m)+1) && row(col(mp)) <= kp && kp < row(col(mp)+1) && m <= l && l < row(i+1) && mp <= lp && lp < row(ip+1) && col(lp+1) <= col(kp) && col(l+1) <= col(k) && col(l) = col(k) && col(lp) = col(kp)}",

     "Efficient Inspector complexity:" : "n*(nnz/n)*(nnz/n)*(nnz/n)*n*(nnz/n)*(nnz/n) = O( nnz^5/n^3 )",

      "Efficient Inspector complexity after domain info (mono adds an useful equlaity: ip = col(m) ):" : "     n*(nnz/n)*(nnz/n)*(nnz/n)*(nnz/n)*(nnz/n) = O( nnz^5/n^4 )",

      "Expected" : "Maybe Satisfiable",
      "Comment: Source of data access in the code for this relation" : [
                    " ",
                    "a write in S3 (val[k]);  a read in S3 (val[l]);"
                  ]
    },
    {
      "Name" : "CSR Incoplete Cholesky 0",
      "Input Type" : "IEgenLIB Relation",
      "Index" : "28",
      "Relation" : "{ [i,m,k,l] -> [ip,mp,kp,lp] : k = lp && ip < i  && 0 <= i && i < n-1 && 0 <= ip && ip < n-1  && row(i)+1 <= m && m < row(i+1) && row(ip)+1 <= mp && mp < row(ip+1) && row(col(m)) <= k && k < row(col(m)+1) && row(col(mp)) <= kp && kp < row(col(mp)+1) && m <= l && l < row(i+1) && mp <= lp && lp < row(ip+1) && col(lp+1) <= col(kp) && col(l+1) <= col(k) && col(l) = col(k) && col(lp) = col(kp)}",

     "Efficient Inspector complexity:" : "n*(nnz/n)*(nnz/n)*(nnz/n)*n*(nnz/n)*(nnz/n) = O( nnz^5/n^3 )",

      "Efficient Inspector complexity after domain info (mono adds an useful equlaity: ip = col(m) ):" : "     n*(nnz/n)*(nnz/n)*(nnz/n)*(nnz/n)*(nnz/n) = O( nnz^5/n^4 )",

      "Expected" : "Maybe Satisfiable",
      "Comment: Source of data access in the code for this relation" : [
                    " ",
                    "a write in S3 (k]);  a read in S3 (val[l]);"
                  ]
    },
    {
      "Name" : "CSR Incoplete Cholesky 0",
      "Input Type" : "IEgenLIB Relation",
      "Index" : "29",
      "Relation" : "{ [i,m,k,l] -> [ip,mp,kp,lp] : k = mp && i < ip  && 0 <= i && i < n-1 && 0 <= ip && ip < n-1  && row(i)+1 <= m && m < row(i+1) && row(ip)+1 <= mp && mp < row(ip+1) && row(col(m)) <= k && k < row(col(m)+1) && row(col(mp)) <= kp && kp < row(col(mp)+1) && m <= l && l < row(i+1) && mp <= lp && lp < row(ip+1) && col(lp+1) <= col(kp) && col(l+1) <= col(k) && col(l) = col(k) && col(lp) = col(kp)}",

     "Efficient Inspector complexity:" : "n*(nnz/n)*(nnz/n)*(nnz/n)*n*(nnz/n)*(nnz/n) = O( nnz^5/n^3 )",

      "Efficient Inspector complexity after domain info (mono adds an useful equlaity: ip = col(m) ):" : "     n*(nnz/n)*(nnz/n)*(nnz/n)*(nnz/n)*(nnz/n) = O( nnz^5/n^4 )",


      "Expected" : "Maybe Satisfiable",
      "Comment: Source of data access in the code for this relation" : [
                    " ",
                    "a write in S3 (val[k]);  a write in S3 (val[m]);"
                  ]
    },
    {
      "Name" : "CSR Incoplete Cholesky 0",
      "Input Type" : "IEgenLIB Relation",
      "Index" : "30",
      "Relation" : "{ [i,m,k,l] -> [ip,mp,kp,lp] : k = mp && ip < i  && 0 <= i && i < n-1 && 0 <= ip && ip < n-1  && row(i)+1 <= m && m < row(i+1) && row(ip)+1 <= mp && mp < row(ip+1) && row(col(m)) <= k && k < row(col(m)+1) && row(col(mp)) <= kp && kp < row(col(mp)+1) && m <= l && l < row(i+1) && mp <= lp && lp < row(ip+1) && col(lp+1) <= col(kp) && col(l+1) <= col(k) && col(l) = col(k) && col(lp) = col(kp)}",

     "Efficient Inspector complexity:" : "n*(nnz/n)*(nnz/n)*(nnz/n)*n*(nnz/n)*(nnz/n) = O( nnz^5/n^3 )",

      "Efficient Inspector complexity after domain info (mono adds an useful equlaity: ip = col(m) ):" : "     n*(nnz/n)*(nnz/n)*(nnz/n)*(nnz/n)*(nnz/n) = O( nnz^5/n^4 )",


      "Expected" : "Maybe Satisfiable",
      "Comment: Source of data access in the code for this relation" : [
                    " ",
                    "a write in S3 (val[k]);  a read in S3 (val[m]);"
                  ]
    }
  ]
]
